# Rapport

> **Groupe :** 

  - ***Rida ADARDOUR*** 

  - ***Tarek OMARI***

  - ***Pierre Chrislin DORIVAL***

# TP Git & Docker ‚Äì Rapport
### Enonc√© :  


Le projet consistait √† am√©liorer l'organisation et la gestion du d√©p√¥t existant docker_tp. Apr√®s l‚Äôavoir clon√© et reli√© √† un nouveau d√©p√¥t distant, j‚Äôai :

- Configur√© un fichier .gitignore adapt√©,

- Utilis√© des branches Git pour le d√©veloppement,

- Marqu√© des versions stables avec des tags,

- Employ√© des commandes avanc√©es comme rebase et cherry-pick,

- Int√©gr√© des outils collaboratifs Git,

- Automatis√© des processus Docker via GitHub Actions.


## T√¢che 1 : Pr√©paration de l'environnement et v√©rification du d√©p√¥t
 
- **1.1. Clonage du d√©p√¥t :**
 
Le d√©p√¥t GitHub fourni (`docker_tp`) a √©t√© clon√© en local √† l‚Äôaide de la commande suivante :
 
```bash
git clone https://github.com/RidaAdar/docker_tp.git
```

![Clonage du d√©p√¥t Git depuis GitHub](Images/capture-config_log.png)

> Cr√©ation d‚Äôun d√©p√¥t local et envoi vers le d√©p√¥t distant en les associant :


```bash
cd docker_tp
# Se d√©placer dans le dossier du projet

git init
# Initialise un d√©p√¥t Git local (le dossier devient un projet versionn√©)

git add .
# Ajoute tous les fichiers du dossier au suivi Git

git commit -m "first commit"
# Cr√©e un premier commit avec un message

git branch -M main
# (Facultatif) Renomme la branche actuelle en 'main' pour suivre la convention GitHub

git remote add origin https://github.com/TON-UTILISATEUR/ton-repo.git
# Associe le d√©p√¥t local √† un d√©p√¥t distant sur GitHub

git push -u origin main
# Envoie la branche 'main' sur GitHub et √©tablit la liaison de suivi entre local et distant
```


* **1.2 Configuration de Git :**
 
Avant toute manipulation, la configuration de l‚Äôenvironnement Git a √©t√© v√©rifi√©e et ajust√©e pour s'assurer que les informations de l'utilisateur sont bien d√©finies.
 
```bash
git config --global user.name "forbiddeone"
git config --global user.email "votremail@example.com"
```
Puis, la configuration a √©t√© v√©rifi√©e avec :

```bash
git config --list
```
**Remarque :** Commande d'importation des photos dans le dossier Images

```bash
cp /mnt/c/Users/tarek/OneDrive/Images/Screenshots/Cpature_config.png /home/forbiddeone/newTP/Images
``` 
 ![Affichage de la configuration Git](Images/capture-config_log.png)

* **1.3. Initialisation du nouveau d√©p√¥t distant**

Apr√®s avoir clon√© le projet, un nouveau d√©p√¥t GitHub a √©t√© cr√©√©. Le lien distant a √©t√© mis √† jour comme suit :

```bash
git remote remove origin
git remote add origin https://github.com/RidaAdar/newTP.git
```

![Changement de d√©p√¥t distant](Images/capture_remote.png)

## T√¢che 2 : Configuration avanc√©e du fichier `.gitignore`
 
* **2.1 Cr√©ation et optimisation du fichier `.gitignore` :**
 
Un fichier `.gitignore` a √©t√© cr√©√© et configur√© pour ignorer les fichiers et dossiers inutiles au suivi de version, en particulier ceux li√©s √† Docker et √† l‚Äôenvironnement local.
 
> Voici les principales entr√©es ajout√©es :

 ```gitignore

 # Python bytecode
 __pycache__/
 *.py[cod]
 *.pyo
 
 # Fichiers de logs
 *.log
 
 # Fichiers temporaires
 *.tmp
 *.swp
 
 # Dossiers de build
 build/
 dist/
 
 # Caches
 .cache/
 *.egg-info/
 .eggs/
 pip-wheel-metadata/
 
 # Environnements virtuels
 .env
 .venv/
 venv/
 env/
 
 # Fichiers secrets
 *.key
 *.pem
 
 # Docker
 .docker/
 docker-compose.override.yml
 Dockerfile~
 *.tar
 *.tar.gz
 
 # Streamlit
 .streamlit/config.toml
 
 # IDEs / √©diteurs
 .vscode/
 .idea/
 
 # Syst√®me (Windows / Mac)
 .DS_Store
 Thumbs.db
 ```
> Mise √† jour du fichier .gitignore
```bash
nano .gitignore
# ou
code .gitignore
```

* **2.2 V√©rification des fichiers ignor√©s :**
 
La commande suivante a √©t√© utilis√©e pour v√©rifier que les fichiers d√©finis dans `.gitignore` ne sont plus suivis par Git :
 
```bash
git status
```

![git status montrant que les fichiers sont ignor√©s](Images/capture_status.png)
 
 > **Commentaires :**
 
   - Les fichiers comme `.log`, `.pyc`, ou les dossiers comme `.venv/`, `build/`, `.vscode/` sont correctement exclus.

   - Cela permet de garder un historique propre et de ne pas polluer le d√©p√¥t avec des fichiers g√©n√©r√©s automatiquement.

 
## T√¢che 3 : Mise en place d‚Äôun workflow de d√©veloppement collaboratif
  
* **3.1 Cr√©ation de branches th√©matiques :**
 
Pour organiser le d√©veloppement collaboratif, plusieurs branches ont √©t√© cr√©√©es, chacune associ√©e √† une fonctionnalit√© ou une correction sp√©cifique :
 
- `feature/generate_dashboard`

- `feature/new_graph`

- `bugfix/division-error`
 
La commande utilis√©e pour cr√©er une branche th√©matique est :
 
```bash
git checkout -b feature/generate_dashboard
```

![Cr√©ation d'une branche locale avec git checkout -b](Images/capture_chekout-branch.png)

 
* **3.2 D√©veloppement et commits :**
 
Sur chaque branche, les modifications sont suivies de commits explicites, en utilisant une s√©mantique standard :
 
```bash
git commit -m "feat: ajout du dashboard interactif"
```
 
**Convention de nommage des messages de commit**
 
- `feat:` ‚Üí ajout d'une nouvelle fonctionnalit√©

- `fix:` ‚Üí correction d‚Äôun bug

- `BREAKING CHANGE:` ‚Üí changement majeur pouvant casser la compatibilit√©

- `perf:` ‚Üí am√©lioration des performances sans changement fonctionnel

üì∏ **Capture d'√©cran 7 (Commit structur√© sur la branche `feature/new_graph`)**  
üëâ ![Commit structur√© sur la branche feature/new_graph](Images/capture_commit.png)

* **3.3 Pull Requests et Revue de code**
 
Une fois le d√©veloppement termin√©, une Pull Request (PR) est cr√©√©e depuis GitHub pour proposer l‚Äôint√©gration des changements dans la branche `main`.
 
üì∏ **Capture d'√©cran 8 (Cr√©ation d‚Äôune Pull Request sur GitHub)**  

üëâ ![Cr√©ation d‚Äôune Pull Request sur GitHub](Images/capture_pullrequest.png)
 
Les co√©quipiers sont invit√©s √† commenter, relire, et approuver les modifications. En cas de conflit, GitHub alerte, et une r√©solution manuelle peut √™tre n√©cessaire avant merge.
 
> **Commentaires :**
 
  - Le syst√®me de PR permet un contr√¥le qualit√© collaboratif avant d‚Äôint√©grer une fonctionnalit√©.

  - Chaque branche reste isol√©e, ce qui √©vite les effets de bord sur `main`.
   
![Discussion et validation d‚Äôune Pull Request](Images/capture_approve_pull.png)

## T√¢che 4 : Utilisation et gestion des tags Git
 
---
 
* **4.1 Cr√©ation de tags pour marquer les versions**
 
Une fois une version stable atteinte (apr√®s l‚Äôint√©gration d‚Äôune fonctionnalit√© compl√®te ou d‚Äôune correction importante), un **tag annot√©** est cr√©√© pour figer cette version dans l‚Äôhistorique Git :
 
```bash
git tag -a v1.0.0 -m "Version 1.0.0 - Premi√®re release stable avec Dockerfile fonctionnel"
```
![Cr√©ation d‚Äôun tag Git annot√©](Images/capture_tag.png)
 
Puis, le tag est pouss√© sur le d√©p√¥t distant :
 
```bash
git push origin --tags
```
![Push du tag vers GitHub](Images/capture_pushtag.png)


* **4.2 V√©rification et listing des tags**
 
Tous les tags cr√©√©s peuvent √™tre list√©s avec la commande :
 
```bash
git tag -l
```

> **Commentaires :**
 
  - L'utilisation de tags permet de **marquer des versions stables** du projet.

  - Cela facilite la navigation dans l‚Äôhistorique et permet de **lier une version √† un livrable pr√©cis** (comme une image Docker).

  - Associ√© √† GitHub Actions, un tag peut d√©clencher automatiquement un build.

 -----
 forbiddeone@Ltranger:~/newTP$ git reset --hard HEAD~1 
HEAD is now at 90723ea  feat: Ajout new_model3

* **4.3 R√©cup√©ration et ex√©cution d‚Äôune image Docker versionn√©e (via GHCR)**
 
Une fois l‚Äôimage pouss√©e sur **GitHub Container Registry (GHCR)**, on peut la r√©cup√©rer avec :
 
```bash
 docker pull ghcr.io/ridaadar/newtp:sha-7b6a4ad
```
![Pull et ex√©cution de l‚Äôimage Docker GHCR](Images/capture_buildim.png)

Et l‚Äôex√©cuter en local :
 
```bash
docker run -p 8502:8501 ghcr.io/ridaadar/newtp:sha-7b6a4ad
```
![Pull et ex√©cution de l‚Äôimage Docker GHCR](Images/capture_pull_image.png)

  **Remarque :**
 
- GHCR facilite le **partage des images Docker versionn√©es**.

- Coupl√© √† **GitHub Actions**, ce m√©canisme permet de **publier automatiquement une image Docker √† chaque release** via un tag Git.

 
>  **T√¢che 4 compl√©t√©e** : les tags Git sont cr√©√©s, pouss√©s et utilis√©s pour piloter la g√©n√©ration d‚Äôimages Docker versionn√©es.

> Option 1: You want to keep those changes permanently
```bash
git add .
git commit -m "save changes before rebase"
git rebase -i HEAD~3
```
> You want to temporarily hide your changes (and bring them back later)
```bash 
git stash
git rebase -i HEAD~3
git stash pop  # bring your changes back after rebase
```
## T√¢che 5 : Exp√©rimentation avec des commandes Git avanc√©es
 
---
 
* **5.1 Rebase interactif**
 
Sur une branche de fonctionnalit√©, un rebase interactif a √©t√© utilis√© pour **r√©organiser les commits**, fusionner certains entre eux, et **renommer les messages** si n√©cessaire :
 
```bash
git rebase -i HEAD~3
```
![Rebase interactif sur la branche feature/clean-history](Images/capture_chery_pick.png)
 
> **Commentaires :**
 
  - Cela permet d‚Äô**am√©liorer la lisibilit√© de l‚Äôhistorique Git**.

  - Les commits sont mieux organis√©s, et les messages plus explicites.

  - Tr√®s utile **avant une Pull Request** pour ne pas polluer `main` avec des commits inutiles ou trop fragment√©s.


* **5.2 Commande `cherry-pick`**
 
Un commit utile d‚Äôune autre branche a √©t√© r√©cup√©r√© dans la branche courante gr√¢ce √† :
 
```bash
git cherry-pick 5ef497c
```

![Cherry-pick d‚Äôun correctif depuis une autre branche](Images/capture_log-list.png)
 
> **Cas d‚Äôusage :**
 
  - Un bug a √©t√© corrig√© dans la branche `bugfix/typo`, mais cette correction est aussi n√©cessaire sur `feature/dashboard`.

  - Plut√¥t que de refaire le commit, on le **"rejoue"** gr√¢ce √† `cherry-pick`.

---
 
* **5.3 Commande `git stash`**
 
Pendant le d√©veloppement, certaines modifications non termin√©es ont √©t√© mises de c√¥t√© temporairement avec :
 
```bash
git stash
```
Et plus tard r√©appliqu√©es avec :
 
```bash
git stash pop
```
 ![stash et r√©cup√©ration de modifications](Images/capture_stash.png)

 
* **5.4 Visualisation de l‚Äôhistorique des branches**
 
L‚Äôarborescence des commits et des branches a √©t√© visualis√©e avec :
 
```bash
git log --graph --oneline --all
```
 

![Historique visuel avec git log --graph](Images/capture_log-list.png)
 
 
De plus, l‚Äôextension Git Graph de VS Code a √©t√© utilis√©e pour un affichage graphique :
 
![Topologie des branches avec Git Graph VS Code](img/git-graph-vscode.png)

 
 > **Commentaires :**

  - Ces outils permettent de mieux **comprendre la structure du projet**, surtout avec plusieurs branches actives.

  - Tr√®s utiles pour les **revues**, les **merges**, et les **validations**.

 
## T√¢che 8 : Documentation et suivi du projet sur GitHub
 
---
 
* **8.1 Utilisation des Issues**
 
Des **issues** ont √©t√© cr√©√©es sur GitHub afin de d√©composer les t√¢ches √† effectuer et **assigner les responsabilit√©s** √† chaque membre de l‚Äô√©quipe.
 )
 
> **Commentaires :**
 
  - Chaque issue repr√©sente une t√¢che sp√©cifique (ex : ajout d‚Äôun mod√®le, correction d‚Äôun bug, cr√©ation du `.gitignore`, etc.).

  - Les issues permettent de **suivre l‚Äô√©tat d‚Äôavancement** du projet en √©quipe.

  - Elles servent √©galement √† **documenter les bugs** rencontr√©s ou les am√©liorations √† venir.
 
---
 
* **8.2 Organisation avec le Project Board**
 
Un **Project Board GitHub** (type Kanban) a √©t√© mis en place pour organiser le travail collaboratif.
 
 
 > **Commentaires :**
 
  - Les issues sont int√©gr√©es au tableau via des cartes que l‚Äôon d√©place au fur et √† mesure de leur avancement.

  - Le tableau comporte trois colonnes principales :  

  $\Longrightarrow$ **Todo** : t√¢ches √† faire  

  $\Longrightarrow$ **In Progress** : t√¢ches en cours  

  $\Longrightarrow$ **Done** : t√¢ches termin√©es

- Cela permet une **vision claire de l‚Äôavancement global du projet**, m√™me √† distance.
 
---
 
> **T√¢che 8 compl√©t√©e :**
 Les outils de suivi GitHub (Issues + Project Board) ont √©t√© utilis√©s efficacement pour structurer le travail d‚Äô√©quipe.

 ## 5. Questions th√©oriques suppl√©mentaires

---

### üîπ Rebase vs Merge

- `git rebase` permet un historique **plus propre et lin√©aire**.
- `git merge` garde l‚Äôhistorique r√©el et est **plus s√ªr en collaboration**.
- **Quand utiliser `rebase` :**
  - Pour organiser ses commits en local, avant de pousser.
- **Quand utiliser `merge` :**
  - Pour int√©grer des branches sur un d√©p√¥t partag√©.
- **Risques avec `rebase` :**
  - Perte de commits si utilis√© apr√®s un push.
- **Conseils :**
  - Ne jamais rebaser une branche d√©j√† partag√©e.
  - Toujours tester ou stasher les changements avant un rebase.

---

### üîπ Int√©r√™t des tags & Semantic Versioning

- Les **tags** servent √† marquer des **versions importantes et stables**.
- Ils facilitent :
  - Les d√©ploiements
  - Le suivi de version
  - Les retours √† un √©tat stable

#### Semantic Versioning : `MAJOR.MINOR.PATCH`
- `MAJOR` ‚Üí changements incompatibles
- `MINOR` ‚Üí nouvelles fonctionnalit√©s compatibles
- `PATCH` ‚Üí corrections de bugs mineures

*Exemple :* `v2.1.3`

---

### üîπ Mauvaise configuration du fichier `.gitignore`

- Peut entra√Æner :
  - L‚Äôajout de fichiers inutiles (logs, binaires, caches‚Ä¶)
  - L‚Äôexposition de donn√©es sensibles (`.env`, cl√©s‚Ä¶)
  - Un d√©p√¥t plus lourd et d√©sorganis√©

#### Pour corriger :

1. Modifier `.gitignore` pour y ajouter les fichiers √† exclure
2. Supprimer les fichiers d√©j√† suivis :

```bash
git rm --cached nom_du_fichier
git commit -m "Nettoyage fichiers ignor√©s"


 
 